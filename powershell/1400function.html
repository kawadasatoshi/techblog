<h1>
    powershell学習サイト
</h1>

<pre>
    <a href="./1_0interactive_shell.html">
        powershell 入門 インタラクティブシェル
    </a>
    <a href="./1_0interactive_shell.html">
        powershell 入門　パイプライン
    </a>    
    <a href="./1_1_1variable.html">
        powershell 入門　変数
    </a>
    <a href="./1_1_2string_text.html">
        powershell 入門　文字列
    </a>
    <a href="./1_2if.html">
        powershell 入門 条件式
    </a>
    <a href="./1_3for.html">
        powershell 入門 繰り返し
    </a>
    <a href="./1_4function.html">
        powershell 入門 関数
    </a>
</pre>

参考:海外版powershellクックブック
URL：http://index-of.co.uk/Microsoft-Windows-Ebooks/OReilly.Windows.PowerShell.Cookbook.Oct.2007.pdf






<h2>
    前回までのお話はこちら
</h2>
<a href="./3for.html">
    powershell 入門 学習サイト 〜繰り返し構文編〜
</a>




<h2>
    関数 </h2>
<p>
    関数の構文 </p>


    
<pre>
function add plus 10 ($Number) [
    $Number++; 
    return $Number
}
</pre>




##関数の引数


###引数を撮る方法1： paramで指定
<pre>
$num1 = 0 echo "num1 is $num1"
#2自分で関数を定義 
function add_plus1 { 
    param (
        $Number
    )
    $Number++;
    return $Number
}
$num2 = add_plus1($num1)
echo "num2 is $num2"
</pre>

これは引数に対して1を加える簡単な関数

$Numberに与えられた数字は$Number++で一つだけ値が増える。


###引数を使う方法2：

<pre>
function add_plus10 ($Number) [
    $Number++; 
    return $Number
}
</pre>

関数名の横に(のなかで引数を指定することもできる)


###引数の型を指定することも可能
<pre>
function add_plus10 ([int]$Number) [
    $Number++; 
    return $Number
}
</pre>
    
引数の前に[]で型を指定することで、それ以外の型以外は代入できなくなる。

万が一以下のように文字列を指定して代入してしまったとしてもエラーが出る

<pre>
add_plus10("アイウエオ")
</pre>

このコードはエラーが出る



##可変長引数

可変な長さの引数を取扱場合はargsを指定すればよい

<pre>
function GetArgumentsFunction
{
    "First positional function argument is: " + $args[0]
    "Second positional function argument is: " + $args[1]
}
</pre>


<pre>
PS > GetArgumentsFunction One Two
Get-Arguments First 2
First named argument is: First
</pre>



##パイプライン入力にアクセスする

サンプルコード

<pre>#filename : somefunction.pms1
function InputCounter {
    $count = 0
    ## Go through each element in the pipeline, and add up
    ## how many elements there were.
    foreach($element in $input){
        $count++ 
    }
    $count
}
</pre>

実行例

<pre>
ImportModule somefunction.pms1
dir $env:WINDIR | InputCounter
295
</pre>

解説

$inputにはパイプラインからの入力が代入される。

多くのコマンドは配列として次のパイプラインが生成されるので受け取り手の関数を作る場合はforeachで回さなければいけない



##begin process end

<pre>
function InputCounter
{
    begin {
        $count = 0 
    }
    ## Go through each element in the pipeline, and add up
    ## how many elements there were.
    process {
        Write-Debug "Processing element $_"
        $count++ 
    }
    end {
        $count 
    }
}
</pre>

関数内の記述はbegin process end　の三段回に分けて書くことができる

この記述方法が大きな影響を及ぼすわけではないが、あなたのソリューションの意図を明確にできる。


以下のコードは同じ意味で機能的には差異がないが、どちらが見やすいだろうか


<pre>
function Get-InputWithKeyword($identifier)
{
begin {
        Write-Host "Beginning InputWithKeyword (ID: $identifier)"
    }
process {
        Write-Host "Processing element $_ (ID: $identifier)"
$_ }
end {
        Write-Host "Ending InputWithKeyword (ID: $identifier)"
    }
}
</pre>

<pre>
function Get-InputWithForeach($identifier)
{
    Write-Host "Beginning InputWithForeach (ID: $identifier)"
    foreach($element in $input)
    {
        Write-Host "Processing element $element (ID: $identifier)"
$element }
    Write-Host "Ending InputWithForeach (ID: $identifier)"
}
</pre>













<h2>例題）：fizz buzzの判定部分を関数として独立させる </h2>
<p>
前回課題のfor文内のコードを関数として独立させよう 
</p>
<pre> 
for ($i=1; $i -it 20; $i++) { if ($i % 15 -eq 0) {
echo "$i is fizzbuzz" } else if ($i % 5 -eq 0) {
echo "$i is buzz" Jelseif ($i % 3 -eq 0) {
echo "$i is fizz"
</pre>
<p>
以下回答
</p>
<pre>











</pre>
<p>
    回答例
</p>
<pre> 
function Judgement-Fizzbuzz($i){ 
    $answer = ""
    if ($i % 15 -eq 0) {
        $answer = "fizzbuzz" }
    else if ($i % 5 -eq 0) {
        $answer = "fizz" }
    else if ($i % 3 -eq 0) {
        $answer = "buzz" return $answer
    }
    return $answer
}
for ($i=1; $i -it 20; $i++) {
    $test = Judgement-Fizzbuzz($i)
    echo $test
}
</pre>





##パワーシェルの引数にスクリプトブロックを指定する


<pre>
##############################################################################
## Map-Object.ps1
##
## Apply the given mapping command to each element of the input
##
## Example:
##    1,2,3 | Map-Object { $_ * 2 }
##############################################################################
param([ScriptBlock] $mapCommand)
process {
    & $mapCommand
}

</pre>

実行例

<pre>
PS >1,2,3 | Map-Object { $_ * 2 }
2
4
6

PS >1,2,3 | Map-Object { ($_ + 2) * 3 }
9
12
15

PS >1,2,3 | Map-Object { ($_ + 3) * $_ }
4
10
18
</pre>

解説

型[ScriptBlock]はその変数に{}で囲まれたpowershellコードを埋め込むことができる。

$_は与えられた引数全体を配列として捉えた時に、その一つ一つの値に同じ処理を施したい時に使う。

例えば

PS >1,2,3 | Map-Object { $_ * 2 }

の場合、1,2,3のそれぞれを表す$_に対して 「$_ * 2」つまり二倍するという処理を施している。

powershellの[ScriptBlock]で定義された$mapCommand変数にはこの{ $_ * 2 }が格納されており、

それをアンパサンド($)を使って実行できる。









title:powershell 入門 学習サイト 〜関数編〜
description:プログラミング言語powershellの入門サイトです。今回は第四弾、関数編
img:https://blog.hubfly.com/wp-content/uploads/2018/12/powershell.png


